blog1(
[
  {
    "time": "2019-03-01",
    "title": "纯css实现时间轴(一)",
    "sign": ["CSS","HTML"],
    "content": "    首先我们用最简单的代码来实现一个时间轴。完成后的效果就像我的博客<a href=\"./blog.html?type=all\" target=\"_blank\">总览</a>那里。这仅仅是1.0版本，后面我们可以做到自定义图标，还可以添加进度条。这次我们先来学习如何用css实现时间轴。首先来看看HTML代码:<code class=\"language-markup\">&lt;div>\n  &lt;div class=\"item\">2019-03-01 活在昨天，你什么都得不到。&lt;/div>\n  &lt;div class=\"item\">2019-02-28 不积跬步无以致千里。&lt;/div>\n  &lt;div class=\"item\">2019-02-27 玩转CSS就靠今天。&lt;/div>\n  &lt;div class=\"item\">2019-02-26 不敲代码的一天手痒痒的。&lt;/div>\n&lt;/div></code>    接下来就是样式了。样式非常简单，首先用after绘制小圆圈，然后用before绘制直线，全部代码如下:<code class=\"language-css\">.item {\n  position: relative;\n  margin: 0 auto;\n  padding: 0 0 20px 20px;\n}\n.item:after {\n  position: absolute;\n  top: 7px;\n  left: -7px;\n  content: '';\n  width: 10px;\n  height: 10px;\n  border: 2px solid #38a4ab;\n  border-radius: 50%;\n  background-color: #fff;\n}\n.item:not(:last-child):before {\n  position: absolute;\n  content: '';\n  width: 1px;\n  left: 0;\n  top: 7px;\n  bottom: -7px;\n  background-color: #38a4ab;\n}</code>    最终的效果图如下:\n<img src=\"./assets/img/blog/2018-2019/2019030101.png\"></img>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "
  },
  {
    "time": "2019-02-22",
    "title": "利用伪元素before和after实现步骤条",
    "sign": ["CSS","HTML"],
    "content": "    利用before和after实现步骤条，我们经常会看到购物下单是你当前进行的步骤、已经完成未完成的步骤，首先我们来看一下效果图:<img class=\"full-img\" src=\"./assets/img/blog/2018-2019/2019022201.png\",></img>    那么那样的进度条怎么实现的呢，当然方法有很多种，我这里就用一种比较简单的方法实现。首先我们需要写HTML代码，为整体大个框框，代码如下：\n<code class=\"language-markup\">&lt;ul class=\"box\">\n  &lt;li class=\"step active\">第一步&lt;/li>\n  &lt;li class=\"step\">第二步&lt;/li>\n  &lt;li class=\"step\">第三步&lt;/li>\n  &lt;li class=\"step\">第四步&lt;/li>\n&lt;/ul></code>    接下来就是我们的样式了，主要是利用伪元素before和after还绘制链接处的三角形：\n<code class=\"language-css\">.box {\n  width: 80%;\n  margin: 0 auto;\n}\n\n.step {\n  background: #ccc;\n  display: inline-block;\n  color: #fff;\n  width: calc(25% - 4px);\n  height: 40px;\n  background-color: #ccc;\n  position: relative;\n  text-align: center;\n  line-height: 40px;\n}\n\n.step:before {\n  content: '';\n  display: block;\n  border-top: 20px solid #ccc;\n  border-bottom: 20px solid #ccc;\n  border-left: 20px solid #fff;\n  position: absolute;\n  left: 0px;\n  top: 0;\n}\n\n.step:after {\n  content: '';\n  display: block;\n  border-top: 20px solid transparent;\n  border-bottom: 20px solid transparent;\n  border-left: 20px solid #ccc;\n  position: absolute;\n  right: -20px;\n  top: 0;\n  z-index: 1;\n}\n\n.step:first-child {\n  border-top-left-radius: 4px;\n  border-bottom-left-radius: 4px;\n}\n\n.step:last-child {\n  border-top-right-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n\n.step:last-child:after {\n  display: none;\n}\n\n.step:first-child:before {\n  display: none;\n}\n\n.step:last-child:after {\n  display: none;\n}\n\n/* 当前状态 */\n.box > .active {\n  background-color: #f39c12;\n}\n\n.box > .active:after {\n  border-left-color: #f39c12;\n}\n\n.box > .active:before {\n  border-top-color: #f39c12;\n  border-bottom-color: #f39c12;\n}\n\n/* 完成状态 */\n.box > .already {\n  background-color: #50abe4;\n}\n\n.box > .already:after {\n  border-left-color: #50abe4;\n}\n\n.box > .already:before {\n  border-top-color: #50abe4;\n  border-bottom-color: #50abe4;\n}</code>"
  },
  {
    "time": "2019-02-16",
    "title": "var、let和const的区别",
    "sign": ["JavaScript","es6"],
    "content": "    我记得在我读大三的时候，去参加某公司的实习生面试的时候，做的面试题的第一道就是这个问题。当然起初也对这个问题有一定的了解，但是了解的程度也只是皮毛，只知道这三个都可以用来声明变量，其中const用来声明常量，其值不可以更改。let和const是es6中的，了解的程度大概就这样。等面试下来，我查阅资料，学到了一些\"不为人知\"知识，接下来听我娓娓道来：\n    1.let和const允许把变量的作用域限制在块级域中；var申明变量要么是全局的，挂载在window上，要么是函数级的，限制在函数作用域内，而无法是块级的。<code class=\"language-javascript\">  function fn(){\n    var username = 'wuufeii';\n    console.log(username);//正确，输出wuufeii\n  }\n  fn();\n  console.log(username);//报错,username is not defined。</code>    2.var声明变量存在变量提升，let和const不存在变量提升\n<code class=\"language-javascript\">  console.log(username);//不报错,返回undefined；因为var会变量提升，相当于在之前会声明var username;但是没有赋值，所以默认值为undefined。\n  var user = 'wuufeii';  \n</code>    如果是以下就会报错了<code class=\"language-javascript\">  console.log(username);//报错,Unexpected identifier 因为let和const不存在变量提升 \n  let user = 'wuufeii';</code>    所以用let和const定义的变量一定要在声明后再使用，否则会报错。\n    3.let和const声明形成块作用域:\n    var只有全局作用域和函数作用域概念，没有块级作用域的概念。但是会把{}内也假称为块作用域。\n    let和const只有块级作用域的概念，由{}包括起来，if语句和for语句里面的{}也属于块级作用域。\n    块级作用域可以嵌套。内部的作用域可以访问到外层作用域。\n    4.同一作用域下let和const不能声明同名变量，而var可以\n<code class=\"language-javascript\">  for(var i = 0; i < 3; i++) {\n    console.log(i); // 0 1 2\n  }\n  console.log(i);// 3\n  /*var声明了变量之后，就一直存在，for循环结束后，他还在。*/\n  var i;\n  console.log(i);//依然还是3\n  for(var i = 0; i < 3; i++) {\n    /*可以继续声明i，并重新赋值*/\n    console.log(i);// 0 1 2\n  }</code><code class=\"language-javascript\">\n   let username = 'wuufeii';\n   let username; //报错,Identifier 'username' has already been declared即变量已经声明过了</code>    但是在不同作用域下可以继续声明，如下：\n<code class=\"language-javascript\">\n  let fn = function(){\n    let username='wuufeii';\n    if(true){\n      let username='fly';\n      console.log(username);//fly    \n    }\n    console.log(username);//wuufeii\n  }\n  fn(); </code>    当先let声明后再var声明<code class=\"language-javascript\">\n  let fn = function(){\n    let username='wuufeii';\n    if(true){\n      var username='fly';// error\n      console.log(username);\n    }\n    console.log(username);\n  }\n  fn();\n  // var 是函数级作用域，相当于这个函数作用域中有let和var声明的两个name的变量了\n  // var 作用于整个getUser，不仅仅是if(if只是个块级作用域，无法限制var) ，和let冲突了，let不能重复声明，already been declared=已经被声明</code>    先var声明再let声明\n    可以正常运行，块级作用域内let覆盖了var定义的变量<code class=\"language-javascript\">  let fn = function(){\n    var username='wuufeii';\n    if(true){\n      let username='fly';\n      console.log(username)//fly;\n    }\n    console.log(username);//wuufeii\n  }\n  fn();</code>    5. const和let区别\n    const一旦声明必须赋值, 必须赋值，必须赋值！不能使用null占位；声明后不能再修改；如果声明的是复合类型数据，可以修改其属性。具体参照后文中const的补充部分。\n    6.暂存死区：ES6明确规定，如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。所以在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n<code class=\"language-javascript\">\n  var username = 'wuufeii';\n  {\n    console.log(username);//wuufeii，块级作用域对于var没效果，会自动查找上面的变量\n    var username = 'fly';\n  }\n  console.log(username);//fly，块级作用域中修改了变量，生效了\n</code><code class=\\\"language-javascript\\\">\n  let username = 'wuufeii';\n  {\n    console.log(username);//error，let直接封闭作用域，这里的变量，不能向上找了向下又找不到\n    let username = 'wuufeii';\n  }\n  console.log(username);\n</code><code class=\\\"language-javascript\\\">\n  let username = 'wuufeii';\n  {\n    let username = 'fly';\n    console.log(username);// fly，这个let只在当前作用域内生效\n  }\n  console.log(username);//wuufeii\n</code><code class=\\\"language-javascript\\\">\n  let username = 'wuufeii';\n  if(true) {\n    console.log(username);//ReferenceError: Cannot access 'username' before initialization\n    let username = \"fly\";\n  }\n</code>    当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，let声明的变量存在变量提升，但是由于死区我们无法在声明前访问这个变量。"
  },
  {
    "time": "2019-02-15",
    "title": "使用回调函数实现JavaScript异步编程",
    "sign": ["JavaScript"],
    "content": "    众所周知，Javascript语言的执行环境是\"单线程\"(single thread)。\n    所谓\"单线程\"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应(假死)，往往就是因为某一段JavaScript代码长时间运行(比如死循环)，导致整个页面卡在这个地方，其他任务无法执行。\n    为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步(Synchronous)和异步(Asynchronous)。\n    \"同步模式\"就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；\"异步模式\"则完全不同，每一个任务有一个或多个回调函数(callback)，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n    \"异步模式\"非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，\"异步模式\"甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。接下来就用回调函数实现JavaScript异步编程。假定有两个函数f1()和f2()，后者等待前者的执行结果<code class=\"language-javascript\">  f1();\n  f2();</code>    如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。\n<code class=\"language-javascript\">\n  function f1(callback){\n    setTimeout(function () {\n      //f1的任务代码\n      callback();\n    }, 1000);\n  }</code>    执行代码就变成下面这样：<code class=\"language-javascript\">  f1(f2);</code>    采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。\n    回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合(Coupling)，流程会很混乱，而且每个任务只能指定一个回调函数。"
  },
  {
    "time": "2018-09-11",
    "title": "如何去学习前端",
    "sign": ["HTML","CSS","JavaScript"],
    "content": "    相信很多人跟我一样，不知道如何去学前端，就像我当初刚接触前端的时候，我也是不知道该从哪儿下手。慢慢的我了解了前端无非就是HTML、CSS、JavaScript,HTML是结构层，它是主体，用来装载各种dom元素；CSS是表示层，它用来装饰各种dom元素；Javascript用来控制dom元素。\n    当我了解这三个的基本关系后我又开始纠结了，网上教程那么多，想什么w3cschool、菜鸟教程、慕课网等等。不仅有详细的文档，也有多姿多彩的视频，那么是应该先从文档着手呢还是边看视频边学习。通过我自己的摸索，我觉得看应该先看文档，因为文档通常是非常详细的，并且能提升你阅读能力，再加上以后你学新的知识你去用新的知识更多情况都是通过文档去获取这些知识。当你文档看完后，你可以快速浏览一下视频，为什么看了文档还要看视频呢？因为视频都是那些大佬在学习之后总结的一些经验，你去看视频一是可以巩固你前面看的文档，让遗忘的知识重新记忆一下，二是有的你没get到的点，可以在大神的讲解下恍然大悟。\n    当你把基本的HTML、CSS、JavaScript学好之后，你就可以开启你的前端旅程了，接下来，你就可以去了解一下大前端丰富的框架了。"
  },
  {
    "time": "2018-09-10",
    "title": "我为什么走上了web前端之路",
    "sign": ["web","java","c++"],
    "content": "    2014年9月，踏入大学，和绝大多数人一样，对大学这新鲜的玩意特别稀奇，以前的苦仿佛解放了，但是这只是一时的痛快，我并没有真正的被大学丰富的生活而感染，我的生活圈子也只是寝室-食堂-教室。大学四年，去图书馆的次数也就那么几次，去借过的书，也没有翻上两页。大学，可能唯一让我“自豪”的也就只能是每次踏着上课铃进教室，进了教室也是玩手机的我，居然奇迹般的没有挂过科，这并不是说我有多聪明，其实也就是我看清了大学的考试模式，知道如何利用考前的几天去抓取重要的信息，然后“对付”了每一场考试罢了。\n    大学里失败的我如果要细讲，可能是要长篇大论才能说清楚，而我今天要提的是为什么我选择了前端这个方向。大学四年学了很多编程语言，学了高级语言程序设计，c++面向对象程序设计，学了C#可视化编程技术，也学了Java程序设计，学了这么多后端语言，仿佛我更应该走后端这条路，可我怎么就选择了前端，说这是爱好完全不过分，比起后端那枯燥的逻辑关系，我更喜欢看到自己的代码带给我完美的视觉体验，可是，我不知道的是前端并不仅仅只是要求我们写一个页面就完事了，他有很多的技术需要你去掌握，并且它的更新速度可能是这些编程里面最快的，就拿简单的今年你被微信公众号的火热所吸引，你花功夫去学，但是明年小程序横空问世，你又要花精力在上面。可能你会说，我做的前端只是PC端，我不搞移动端。当然，我的举例只是想说前端的更新速度，也许这举例并不是很对。\n    但是，当初凭爱好选择了前端，我就要坚持下去，我不保证我能坚持多久，但是既然现在我还热爱她，你我就要像爱人一样对待她。"
  }
])
